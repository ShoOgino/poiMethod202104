    /**
     * <p><cite>2.3.4.11 Encryption Key Generation (Agile Encryption)</cite></p>
     *
     * <p>The final hash data that is used for an encryption key is then generated by using the following
     * method:</p>
     *
     * <pre>H_final = H(H_n + blockKey)</pre>
     *
     * <p>where blockKey represents an array of bytes used to prevent two different blocks from encrypting
     * to the same cipher text.</p>
     *
     * <p>If the size of the resulting H_final is smaller than that of PasswordKeyEncryptor.keyBits, the key
     * MUST be padded by appending bytes with a value of 0x36. If the hash value is larger in size than
     * PasswordKeyEncryptor.keyBits, the key is obtained by truncating the hash value.</p>
     *
     * @param passwordHash the hashed password byte
     * @param hashAlgorithm the hash algorithm
     * @param blockKey the block key
     * @param keySize the key size
     * @return intermediate key
     */
    public static byte[] generateKey(byte[] passwordHash, HashAlgorithm hashAlgorithm, byte[] blockKey, int keySize) {
        MessageDigest hashAlgo = getMessageDigest(hashAlgorithm);
        hashAlgo.update(passwordHash);
        byte[] key = hashAlgo.digest(blockKey);
        return getBlock36(key, keySize);
    }

