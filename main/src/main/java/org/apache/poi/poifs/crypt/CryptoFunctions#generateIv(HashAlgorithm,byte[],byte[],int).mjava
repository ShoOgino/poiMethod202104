    /**
     * <p><cite>2.3.4.12 Initialization Vector Generation (Agile Encryption)</cite></p>
     *
     * <p>Initialization vectors are used in all cases for agile encryption. An initialization vector MUST be
     * generated by using the following method, where H() is a hash function that MUST be the same as
     * specified in section 2.3.4.11 and a plus sign (+) represents concatenation:</p>
     * <ul>
     * <li>If a blockKey is provided, let IV be a hash of the KeySalt and the following value:<br>
     *     {@code blockKey: IV = H(KeySalt + blockKey)}</li>
     * <li>If a blockKey is not provided, let IV be equal to the following value:<br>
     *     {@code KeySalt:IV = KeySalt}</li>
     * <li>If the number of bytes in the value of IV is less than the the value of the blockSize attribute
     *     corresponding to the cipherAlgorithm attribute, pad the array of bytes by appending 0x36 until
     *     the array is blockSize bytes. If the array of bytes is larger than blockSize bytes, truncate the
     *     array to blockSize bytes.</li>
     * </ul>
     **/
    public static byte[] generateIv(HashAlgorithm hashAlgorithm, byte[] salt, byte[] blockKey, int blockSize) {
        byte[] iv = salt;
        if (blockKey != null) {
            MessageDigest hashAlgo = getMessageDigest(hashAlgorithm);
            hashAlgo.update(salt);
            iv = hashAlgo.digest(blockKey);
        }
        return getBlock36(iv, blockSize);
    }

