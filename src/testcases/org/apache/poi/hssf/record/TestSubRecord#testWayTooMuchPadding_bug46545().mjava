	/**
	 * Some versions of POI (e.g. 3.1 - prior to svn r707450 / bug 45778) interpreted the ftLbs 
	 * subrecord second short (0x1FEE) as a length, and hence read lots of extra padding.  This 
	 * buffer-overrun in {@link RecordInputStream} happened silently due to problems later fixed
	 * in svn 707778. When the ObjRecord is written, the extra padding is written too, making the 
	 * record 8224 bytes long instead of 70.  
	 * (An aside: It seems more than a coincidence that this problem creates a record of exactly
	 * {@link RecordInputStream#MAX_RECORD_DATA_SIZE} but not enough is understood about 
	 * subrecords to explain this.)<br/>
	 * 
	 * Excel reads files with this excessive padding OK.  It also truncates the over-sized
	 * ObjRecord back to the proper size.  POI should do the same.
	 */
	public void testWayTooMuchPadding_bug46545() {
		byte[] data = HexRead.readFromString(""
			+ "15 00 12 00 14 00 13 00 01 21 00 00 00"
			+ "00 98 0B 5B 09 00 00 00 00 0C 00 14 00 00 00 00 00 00 00 00"
			+ "00 00 00 01 00 01 00 00 00 10 00 00 00 "
			// ftLbs
			+ "13 00 EE 1F 00 00 "
			+ "01 00 00 00 01 06 00 00 02 00 08 00 75 00 "
			// ftEnd
			+ "00 00 00 00"
		);
		final int LBS_START_POS = 0x002E;
		final int WRONG_LBS_SIZE = 0x1FEE;
		assertEquals(0x0013, LittleEndian.getShort(data, LBS_START_POS+0));
		assertEquals(WRONG_LBS_SIZE, LittleEndian.getShort(data, LBS_START_POS+2));
		int wrongTotalSize = LBS_START_POS + 4 + WRONG_LBS_SIZE;
		byte[] wrongData = new byte[wrongTotalSize];
		System.arraycopy(data, 0, wrongData, 0, data.length);
		// wrongData has the ObjRecord data as would have been written by v3.1 
		
		RecordInputStream in = TestcaseRecordInputStream.create(ObjRecord.sid, wrongData);
		ObjRecord or;
		try {
			or = new ObjRecord(in);
		} catch (RecordFormatException e) {
			if (e.getMessage().startsWith("Leftover 8154 bytes in subrecord data")) {
				throw new AssertionFailedError("Identified bug 46545");
			}
			throw e;
		}
		// make sure POI properly truncates the ObjRecord data
		byte[] data2 = or.serialize();
		TestcaseRecordInputStream.confirmRecordEncoding(ObjRecord.sid, data, data2);
	}

