    /**
     * <p>Writes a variant value to an output stream. This method ensures that
     * always a multiple of 4 bytes is written.</p>
     *
     * <p>If the codepage is UTF-16, which is encouraged, strings
     * <strong>must</strong> always be written as {@link Variant#VT_LPWSTR}
     * strings, not as {@link Variant#VT_LPSTR} strings. This method ensure this
     * by converting strings appropriately, if needed.</p>
     *
     * @param out The stream to write the value to.
     * @param type The variant's type.
     * @param value The variant's value.
     * @param codepage The codepage to use to write non-wide strings
     * @return The number of entities that have been written. In many cases an
     * "entity" is a byte but this is not always the case.
     * @exception IOException if an I/O exceptions occurs
     * @exception WritingNotSupportedException if a property is to be written
     * who's variant type HPSF does not yet support
     */
    public static int write(final OutputStream out, final long type,
                            final Object value, final int codepage)
        throws IOException, WritingNotSupportedException
    {
        int length = 0;
        switch ((int) type)
        {
            case Variant.VT_BOOL:
            {
                if ( ( (Boolean) value ).booleanValue() )
                {
                    out.write( 0xff );
                    out.write( 0xff );
                }
                else
                {
                    out.write( 0x00 );
                    out.write( 0x00 );
                }
                length += 2;
                break;
            }
            case Variant.VT_LPSTR:
            {
                CodePageString codePageString = new CodePageString( (String) value,
                        codepage );
                length += codePageString.write( out );
                break;
            }
            case Variant.VT_LPWSTR:
            {
                final int nrOfChars = ( (String) value ).length() + 1;
                length += TypeWriter.writeUIntToStream( out, nrOfChars );
                char[] s = ( (String) value ).toCharArray();
                for ( int i = 0; i < s.length; i++ )
                {
                    final int high = ( ( s[i] & 0x0000ff00 ) >> 8 );
                    final int low = ( s[i] & 0x000000ff );
                    final byte highb = (byte) high;
                    final byte lowb = (byte) low;
                    out.write( lowb );
                    out.write( highb );
                    length += 2;
                }
                // NullTerminator
                out.write( 0x00 );
                out.write( 0x00 );
                length += 2;
                break;
            }
            case Variant.VT_CF:
            {
                final byte[] b = (byte[]) value;
                out.write(b);
                length = b.length;
                break;
            }
            case Variant.VT_EMPTY:
            {
                length += TypeWriter.writeUIntToStream( out, Variant.VT_EMPTY );
                break;
            }
            case Variant.VT_I2:
            {
                length += TypeWriter.writeToStream( out,
                        ( (Integer) value ).shortValue() );
                break;
            }
            case Variant.VT_I4:
            {
                if (!(value instanceof Integer))
                {
                    throw new ClassCastException("Could not cast an object to "
                            + Integer.class.toString() + ": "
                            + value.getClass().toString() + ", "
                            + value.toString());
                }
                length += TypeWriter.writeToStream(out,
                          ((Integer) value).intValue());
                break;
            }
            case Variant.VT_I8:
            {
                length += TypeWriter.writeToStream(out, ((Long) value).longValue());
                break;
            }
            case Variant.VT_R8:
            {
                length += TypeWriter.writeToStream(out,
                          ((Double) value).doubleValue());
                break;
            }
            case Variant.VT_FILETIME:
            {
                long filetime = Util.dateToFileTime((Date) value);
                int high = (int) ((filetime >> 32) & 0x00000000FFFFFFFFL);
                int low = (int) (filetime & 0x00000000FFFFFFFFL);
                Filetime filetimeValue = new Filetime( low, high);
                length += filetimeValue.write( out );
                break;
            }
            default:
            {
                /* The variant type is not supported yet. However, if the value
                 * is a byte array we can write it nevertheless. */
                if (value instanceof byte[])
                {
                    final byte[] b = (byte[]) value;
                    out.write(b);
                    length = b.length;
                    writeUnsupportedTypeMessage
                        (new WritingNotSupportedException(type, value));
                }
                else
                    throw new WritingNotSupportedException(type, value);
                break;
            }
        }

        /* pad values to 4-bytes */
        while ( ( length & 0x3 ) != 0 )
        {
            out.write( 0x00 );
            length++;
        }

        return length;
    }

